<body>
    <div id="container"></div>
    <script src="js/three.min.js"></script>
    <script src="js/dat.gui.min.js"></script>
    <script id="vertexShader" type="x-shader/x-vertex">
        void main() {
            gl_Position = vec4( position, 1.0 );
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        //Define the precision
        precision mediump float;

        uniform sampler2D iChannel0;
        uniform sampler2D iChannel1;
        uniform vec2 u_resolution;
        uniform vec2 u_displacement;
        uniform float u_time;       // Time in seconds since load
        uniform bool u_wrapPixelsAround;


        // All components are in the range [0â€¦1], including hue.
        vec3 rgb2hsv(vec3 c)
        {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        void main( void ) {

            float xHelper = 1.0;
            float yHelper = 1.0;

            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            vec4 maskColor = texture2D(iChannel1, uv);

            //convert to HSV
            vec3 maskHSV = rgb2hsv(vec3(maskColor.r, maskColor.g, maskColor.b));

            float brightness = 1.0 - maskHSV.z;
            
            //calculate pixel-to-mimic position
            vec2 lastPos = uv + vec2(brightness-0.5)*u_displacement;
            
            if(u_wrapPixelsAround) {
                if(fract(lastPos.x) == 0.0) {
                    yHelper = 0.0;
                }
                if (fract(lastPos.y) == 0.0) {
                    xHelper = 0.0;
                }
                gl_FragColor =  texture2D(iChannel0, vec2(fract(lastPos.x)*xHelper, fract(lastPos.y)*yHelper));
                xHelper = 1.0;
                yHelper = 1.0;
    
            } else {
                //if pixel is outside original image, paint it black
                if(lastPos.x > 1.0 || lastPos.x < 0.0 || lastPos.y > 1.0 ||  lastPos.y < 0.0) {
                    gl_FragColor = vec4(0.0);
                } else {
                    gl_FragColor =  texture2D(iChannel0, uv + vec2(brightness-0.5)*u_displacement );
                }
            }
        }
    </script>
    <script>

        var FizzyText = function() {
            this.MaxHorizontalDisplacement = 0.1;
            this.MaxVerticalDisplacement = 0.1;
            this.imageURL = "https://i.ibb.co/rQkhD97/0.jpg";
            this.DisplacementMapLayer = "https://i.ibb.co/FJWXGCt/layer-v1.png";
            this.wrapPixelsAround = false;
        };

        var container;
        var camera, scene, renderer;
        var uniforms;
        var text = new FizzyText();
        var gui = new dat.GUI();
        var maskImage, gameImage;

        init();
        animate();

        window.onload = function() {
            gui.add(text, 'imageURL').onChange(function(value) {
                gameImage = new THREE.TextureLoader().load(text.imageURL, (texture) => { 
                    uniforms.iChannel0.value = texture;
                    uniforms.iChannel0.needsUpdate = true;
                });
            });
            gui.add(text, 'DisplacementMapLayer').onChange(function(value) {
                maskImage = new THREE.TextureLoader().load(text.DisplacementMapLayer, (texture) => { 
                    uniforms.iChannel1.value = texture;
                    uniforms.iChannel1.needsUpdate = true;
                });
            });
            gui.add(text, 'MaxHorizontalDisplacement', -1.0, 1.0);
            gui.add(text, 'MaxVerticalDisplacement', -1.0, 1.0);
            gui.add(text, 'wrapPixelsAround').onChange((value) => {
                uniforms.u_wrapPixelsAround.value = value;
            });
        };

        function init() {
            container = document.getElementById( 'container' );

            camera = new THREE.Camera();
            camera.position.z = 1;

            scene = new THREE.Scene();

            var geometry = new THREE.PlaneBufferGeometry( 2, 2 );

            //cant load images locally  https://i.ibb.co/kGF0sMW/Untitled.png
            //var maskImage = new THREE.TextureLoader().load( "https://raw.githubusercontent.com/OmarShehata/Using-Displacement-Shaders-to-Create-an-Underwater-Effect/master/assets/mask.png" );            
            //HALF IMAGE
            //var maskImage = new THREE.TextureLoader().load( "https://i.ibb.co/kGF0sMW/Untitled.png" );
            //1/3 IMAGE  
            maskImage = new THREE.TextureLoader().load( text.DisplacementMapLayer );  
            //ORIGINAL
            //var gameImage = new THREE.TextureLoader().load( "https://raw.githubusercontent.com/OmarShehata/Using-Displacement-Shaders-to-Create-an-Underwater-Effect/master/assets/game_screenshot.png" );
            //1ST USED IMAGE
            gameImage = new THREE.TextureLoader().load( text.imageURL );
            //MAN IMAGE https://i.ibb.co/h1pZRzR/Capture.png
            uniforms = {
                u_time: { type: "1f", value: 0 },
                u_resolution :{type:'v2', value:new THREE.Vector2()},
                u_displacement :{type :'v2', value:new THREE.Vector2()},
                u_wrapPixelsAround :{type: 'bool', value: false},
                iChannel0 :{type:'sampler2D', value:gameImage},
                iChannel1 :{type:'sampler2D', value:maskImage}
            };

            uniforms.u_displacement.value.x = 0.1;
            uniforms.u_displacement.value.y = 0.1;

            var material = new THREE.ShaderMaterial( {
                uniforms: uniforms,
                //vertexShader: document.getElementById( 'vertexShader' ).textContent, //vertex
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent //pixel
            } );

            //testing purpose
            //var material = new THREE.MeshBasicMaterial ( { map: gameImage});

            var mesh = new THREE.Mesh( geometry, material );
            scene.add( mesh );

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );

            container.appendChild( renderer.domElement );

            onWindowResize();
            window.addEventListener( 'resize', onWindowResize, false );

        }

        function onWindowResize( event ) {
            renderer.setSize( window.innerWidth, window.innerHeight );
            uniforms.u_resolution.value.x = renderer.domElement.width;
            uniforms.u_resolution.value.y = renderer.domElement.height;
        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            uniforms.u_displacement.value.x = text.MaxHorizontalDisplacement;
            uniforms.u_displacement.value.y = text.MaxVerticalDisplacement;
            uniforms.u_time.value += 0.05;
            renderer.render( scene, camera );
        }
    </script>
</body>